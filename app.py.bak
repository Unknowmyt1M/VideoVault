import os
import logging
import tempfile
import json
import time
import subprocess
from datetime import datetime
from urllib.parse import urlparse

# Import our JSON database
from json_database import JSONDatabase

def format_duration(seconds):
    """Format duration from seconds to HH:MM:SS"""
    if not seconds:
        return "00:00"

    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)

    if hours > 0:
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"
    return f"{minutes:02d}:{secs:02d}"
    
from flask import Flask, render_template, request, jsonify, flash, session, redirect, send_file
import yt_dlp
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import Flow
import requests
from urllib.parse import urlparse, parse_qs
from flask_login import LoginManager, current_user, login_required

# Initialize the JSON database
db = JSONDatabase()

def is_valid_youtube_url(url):
    try:
        parsed_url = urlparse(url)
        if parsed_url.netloc in ['youtube.com', 'www.youtube.com', 'youtu.be']:
            if parsed_url.netloc == 'youtu.be':
                return bool(parsed_url.path[1:])
            if parsed_url.path == '/watch':
                return bool(parse_qs(parsed_url.query).get('v'))
            return False
        return False
    except:
        return False

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Temporary directory for storing downloads
temp_dir = tempfile.gettempdir()

# Google Drive API scopes
SCOPES = ['https://www.googleapis.com/auth/drive.file']

# Create a mock User class for Flask-Login compatibility
class User:
    def __init__(self, user_data):
        self.id = user_data['id']
        self.username = user_data['username']
        self.email = user_data['email']
        self.is_authenticated = True
        self.is_active = True
        self.is_anonymous = False
    
    def get_id(self):
        return str(self.id)
    
    def to_dict(self):
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email
        }

# User loader for Flask-Login
def load_user(user_id):
    user_data = db.get_user_by_id(int(user_id))
    if user_data:
        return User(user_data)
    return None

def register_routes(app):
    """Register all routes with the Flask app"""
    
    # Define route functions inside this function to avoid global scope
    
    @app.route('/')
    def index():
        """Render the main page with options"""
        return render_template('index.html')

    @app.route('/download')
    def download_page():
        """Render the download page"""
        return render_template('download.html')

    @app.route('/metadata')
    def metadata_page():
        """Render the metadata extraction page"""
        return render_template('metadata.html')

    @app.route('/get_metadata', methods=['POST'])
    def get_metadata():
        """Extract metadata from YouTube URL"""
        try:
            data = request.get_json()
            url = data.get('url', '')

            if not is_valid_youtube_url(url):
                return jsonify({'error': 'Invalid YouTube URL'}), 400

            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

            return jsonify({
                'title': info.get('title', 'Unknown title'),
                'description': info.get('description', 'No description available'),
                'channel': info.get('uploader', 'Unknown channel'),
                'duration': format_duration(info.get('duration', 0)),
                'tags': info.get('tags', [])
            })
        except Exception as e:
            logger.error(f"Error extracting metadata: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/history_page')
    def history_page():
        """Render the history page"""
        return render_template('history.html')

    @app.route('/auth')
    def auth():
        """Start the OAuth flow - redirects to the Google Auth blueprint"""
        return redirect('/google_login')

    @app.route('/get_video_info', methods=['POST'])
    def get_video_info():
        """Get video information from YouTube URL"""
        try:
            data = request.get_json()
            url = data.get('url', '')

            # Validate YouTube URL
            parsed_url = urlparse(url)
            if 'youtube.com' not in parsed_url.netloc and 'youtu.be' not in parsed_url.netloc:
                return jsonify({'error': 'Invalid YouTube URL'}), 400

            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'skip_download': True,
                # Removed 'format': 'best' to let yt-dlp choose available formats
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

            return jsonify({
                'title': info.get('title', 'Unknown title'),
                'duration': info.get('duration', 0),
                'thumbnail': info.get('thumbnail', ''),
                'uploader': info.get('uploader', 'Unknown uploader'),
            })
        except Exception as e:
            logger.error(f"Error getting video info: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/download', methods=['POST'])
    def download_video():
        """Download video from YouTube URL"""
        data = request.get_json()
        logger.info(f"Download data received: {data}")

        url = data.get('url', '')

        # Create a unique filename
        timestamp = int(time.time())
        temp_file = os.path.join(temp_dir, f"yt_video_{timestamp}")
        temp_file_mp4 = temp_file + '.mp4'  # Default to mp4 for backup methods
        logger.info(f"Temp file path: {temp_file}")

        # For testing, use the simplest command possible
        try:
            subprocess.run(['pip', 'list'], capture_output=True, text=True)

            # Use most compatible format with resolution limit for faster download
            cmd = f"yt-dlp -f 'bestvideo[height<=360][ext=mp4]+bestaudio[ext=m4a]/mp4[height<=360]' --no-check-certificate --no-cache-dir -o '{temp_file_mp4}' '{url}'"
            logger.info(f"Running direct command: {cmd}")
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            try:
                stdout, stderr = process.communicate(timeout=240)  # 4 minute timeout
                if process.returncode != 0:
                    raise Exception(f"Download failed: {stderr.decode()}")
            except subprocess.TimeoutExpired:
                process.kill()
                raise Exception("Download timed out after 4 minutes")

            if os.path.exists(temp_file_mp4):
                logger.info(f"File downloaded successfully: {temp_file_mp4}")

                # Get metadata
                try:
                    with yt_dlp.YoutubeDL({'quiet': True, 'skip_download': True}) as ydl:
                        info = ydl.extract_info(url, download=False)

                    video_info = {
                        'youtube_id': info.get('id', ''),
                        'title': info.get('title', 'Unknown'),
                        'duration': info.get('duration', 0),
                        'thumbnail_url': info.get('thumbnail', ''),
                        'uploader': info.get('uploader', 'Unknown uploader'),
                        'filename': temp_file_mp4
                    }
                except Exception as e:
                    logger.warning(f"Could not get metadata: {e}")
                    # Fallback metadata
                    video_info = {
                        'youtube_id': url.split('v=')[-1] if 'v=' in url else url.split('/')[-1],
                        'title': os.path.basename(temp_file_mp4),
                        'duration': 0,
                        'thumbnail_url': '',
                        'uploader': 'Unknown',
                        'filename': temp_file_mp4
                    }

                return process_downloaded_video(url, video_info)

        except Exception as e:
            logger.error(f"Download error: {e}")

            # Last attempt - basic pytube
            try:
                logger.info("Trying basic pytube...")
                from pytube import YouTube
                yt = YouTube(url)
                highest_res_stream = yt.streams.get_highest_resolution()
                if highest_res_stream:
                    download_path = highest_res_stream.download(output_path=temp_dir, filename=f"yt_video_{timestamp}.mp4")
                    logger.info(f"Downloaded with pytube: {download_path}")

                    if os.path.exists(download_path):
                        video_info = {
                            'youtube_id': yt.video_id,
                            'title': yt.title,
                            'duration': yt.length,
                            'thumbnail_url': yt.thumbnail_url,
                            'uploader': yt.author,
                            'filename': download_path
                        }
                        return process_downloaded_video(url, video_info)
            except Exception as pytube_error:
                logger.error(f"Basic pytube error: {pytube_error}")

        # If all methods fail
        return jsonify({'error': 'All download methods failed'}), 500

    def process_downloaded_video(url, video_info):
        """Process a successfully downloaded video and create database entry"""
        try:
            filename = video_info['filename']
            # Get file size
            file_size = os.path.getsize(filename)
            logger.info(f"File size: {file_size} bytes")

            # Prepare video data for JSON database
            video_data = {
                'youtube_id': video_info['youtube_id'],
                'title': video_info['title'],
                'url': url,
                'duration': video_info['duration'],
                'thumbnail_url': video_info['thumbnail_url'],
                'uploader': video_info['uploader'],
                'file_size': file_size,
                'download_success': True,
                'uploaded_to_drive': False,
                'drive_file_id': None,
                'drive_folder_id': None,
                'uploaded_to_youtube': False,
                'youtube_upload_id': None,
                'user_id': current_user.id if hasattr(current_user, 'id') and not current_user.is_anonymous else None
            }

            # Create video record in JSON database
            video = db.create_video(video_data)
            logger.info(f"Video record created with ID: {video['id']}")

            # Add video ID to response for later reference
            response_data = {
                'status': 'success',
                'message': 'Video downloaded successfully',
                'filename': filename,
                'title': video_info['title'],
                'video_id': video['id']
            }
            logger.info(f"Sending response with data: {response_data}")
            return jsonify(response_data)
        except Exception as e:
            logger.error(f"Error processing downloaded video: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/upload_to_drive', methods=['POST'])
    def upload_to_drive():
        """Upload video to Google Drive"""
        try:
            data = request.get_json()
            filename = data.get('filename', '')
            folder_id = data.get('folder_id', None)
            video_id = data.get('video_id', None)

            if not os.path.exists(filename):
                return jsonify({'error': 'File not found'}), 404

            drive_service = get_authenticated_service()
            if not drive_service:
                return jsonify({'error': 'Not authenticated with Google Drive'}), 401

            # Create file metadata
            file_metadata = {
                'name': os.path.basename(filename),
            }

            if folder_id:
                file_metadata['parents'] = [folder_id]

            # Upload file
            media = MediaFileUpload(
                filename, 
                resumable=True
            )

            file = drive_service.files().create(
                body=file_metadata,
                media_body=media,
                fields='id'
            ).execute()

            # Update database record if video_id was provided
            if video_id:
                video = db.get_video_by_id(int(video_id))
                if video:
                    db.update_video(int(video_id), {
                        'uploaded_to_drive': True,
                        'drive_file_id': file.get('id'),
                        'drive_folder_id': folder_id
                    })

            return jsonify({
                'status': 'success',
                'message': 'Video uploaded to Google Drive',
                'file_id': file.get('id')
            })
        except Exception as e:
            logger.error(f"Upload error: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/get_drive_folders', methods=['GET'])
    def get_drive_folders():
        """Get list of Google Drive folders"""
        try:
            drive_service = get_authenticated_service()
            if not drive_service:
                return jsonify({'error': 'Not authenticated with Google Drive'}), 401

            # Query all folders including those in shared drives and shared with the user
            results = drive_service.files().list(
                q="mimeType='application/vnd.google-apps.folder'",
                spaces='drive',
                fields='files(id, name, parents)',
                pageSize=1000,  # Get maximum number of folders
                includeItemsFromAllDrives=True,
                supportsAllDrives=True
            ).execute()

            folders = results.get('files', [])
            logger.info(f"Found {len(folders)} folders")

            # Sort folders by name for better display
            folders.sort(key=lambda x: x.get('name', '').lower())

            return jsonify({'folders': folders})
        except Exception as e:
            logger.error(f"Error getting folders: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/api/upload_to_yt', methods=['POST'])
    def upload_to_yt():
        """Upload video to YouTube with original metadata"""
        try:
            data = request.get_json()
            logger.info(f"YouTube upload with original metadata data received: {data}")

            filename = data.get('filename', '')
            video_id = data.get('video_id', None)
            privacy_status = data.get('privacy_status', 'private')

            if not os.path.exists(filename):
                return jsonify({'error': 'File not found'}), 404

            # Get the original video's metadata
            if video_id:
                video = db.get_video_by_id(int(video_id))
                if not video:
                    return jsonify({'error': 'Video record not found'}), 404

                youtube_id = video['youtube_id']

                # Get metadata using yt-dlp
                try:
                    logger.info(f"Fetching metadata for video ID: {youtube_id}")

                    with yt_dlp.YoutubeDL({'quiet': True, 'skip_download': True}) as ydl:
                        info = ydl.extract_info(f"https://www.youtube.com/watch?v={youtube_id}", download=False)

                    title = info.get('title', 'Unknown title')
                    description = info.get('description', '')
                    tags = info.get('tags', [])
                    category_id = info.get('categories', ['22'])[0] if info.get('categories') else '22'

                    logger.info(f"Original metadata fetched: title='{title}', tags={tags}")
                except Exception as e:
                    logger.error(f"Error fetching original metadata: {e}")
                    return jsonify({'error': f'Could not fetch original metadata: {str(e)}'}), 500
            else:
                return jsonify({'error': 'Video ID is required for upload with original metadata'}), 400

            # Now upload to YouTube with the original metadata
            # Google OAuth credentials from session
            if 'credentials' not in session:
                return jsonify({'error': 'Not authenticated with Google, please login first'}), 401

            # Build the YouTube API service object
            creds_data = json.loads(session['credentials'])
            credentials = Credentials(
                token=creds_data['token'],
                refresh_token=creds_data['refresh_token'],
                token_uri=creds_data['token_uri'],
                client_id=creds_data['client_id'],
                client_secret=creds_data['client_secret'],
                scopes=creds_data['scopes']
            )

            # Check if YouTube scope is present
            if 'https://www.googleapis.com/auth/youtube.upload' not in credentials.scopes:
                return jsonify({'error': 'YouTube upload permission not granted', 'action_required': 'reauth'}), 403

            # Build YouTube API client
            youtube = build('youtube', 'v3', credentials=credentials)

            # Prepare video upload metadata
            body = {
                'snippet': {
                    'title': title,
                    'description': description,
                    'tags': tags,
                    'categoryId': '22'  # Using default category 22 (People & Blogs) as safe default
                },
                'status': {
                    'privacyStatus': privacy_status,
                    'embeddable': True
                }
            }

            # Upload the video
            media = MediaFileUpload(
                filename,
                resumable=True
            )

            # Execute the upload request
            insert_request = youtube.videos().insert(
                part=','.join(body.keys()),
                body=body,
                media_body=media
            )

            # This is a simplified version without a resumable upload
            response = insert_request.execute()

            logger.info(f"YouTube upload successful: {response}")

            # Update database
            if video_id:
                db.update_video(int(video_id), {
                    'uploaded_to_youtube': True,
                    'youtube_upload_id': response.get('id')
                })

            return jsonify({
                'status': 'success',
                'message': 'Video uploaded to YouTube with original metadata',
                'youtube_video_id': response.get('id')
            })

        except Exception as e:
            logger.error(f"Error uploading to YouTube with original metadata: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/upload_to_youtube', methods=['POST'])
    def upload_to_youtube():
        """Upload video to YouTube"""
        try:
            data = request.get_json()
            logger.info(f"YouTube upload data received: {data}")

            filename = data.get('filename', '')
            video_id = data.get('video_id', None)
            title = data.get('title', os.path.basename(filename))
            description = data.get('description', 'Uploaded via YouTube Downloader App')
            tags = data.get('tags', '').split(',') if data.get('tags') else []
            category_id = data.get('category_id', '22')  # Default: "People & Blogs"
            privacy_status = data.get('privacy_status', 'private')  # Default: private

            logger.info(f"Checking file: {filename}, exists: {os.path.exists(filename) if filename else 'No filename provided'}")

            if not filename:
                return jsonify({'error': 'No video file available for upload'}), 400

            if not os.path.exists(filename):
                return jsonify({'error': 'File not found'}), 404

            # Get authenticated service
            credentials_data = json.loads(session.get('credentials', '{}'))
            if not credentials_data:
                return jsonify({'error': 'Not authenticated with Google'}), 401

            credentials = Credentials(
                token=credentials_data.get('token'),
                refresh_token=credentials_data.get('refresh_token'),
                token_uri=credentials_data.get('token_uri'),
                client_id=credentials_data.get('client_id'),
                client_secret=credentials_data.get('client_secret'),
                scopes=credentials_data.get('scopes')
            )

            if credentials.expired:
                request_obj = Request()
                credentials.refresh(request_obj)
                # Update stored credentials
                credentials_data['token'] = credentials.token
                session['credentials'] = json.dumps(credentials_data)

            youtube_service = build('youtube', 'v3', credentials=credentials)

            # Create video metadata
            body = {
                'snippet': {
                    'title': title,
                    'description': description,
                    'tags': tags,
                    'categoryId': '22'  # Using default category 22 (People & Blogs) as safe default
                },
                'status': {
                    'privacyStatus': privacy_status
                }
            }

            # Create media upload with progress reporting
            media = MediaFileUpload(
                filename, 
                mimetype='video/mp4',
                resumable=True,
                chunksize=1024*1024
            )

            # Upload video
            request_obj = youtube_service.videos().insert(
                part=','.join(body.keys()),
                body=body,
                media_body=media
            )

            response = None
            last_progress = 0

            while response is None:
                status, response = request_obj.next_chunk()
                if status:
                    progress = int(status.progress() * 100)
                    # Only log if progress has changed significantly
                    if progress - last_progress >= 5:
                        logger.info(f"YouTube upload progress: {progress}%")
                        last_progress = progress

            youtube_video_id = response.get('id')
            logger.info(f"Video uploaded successfully to YouTube. ID: {youtube_video_id}")

            # Update database record
            if video_id:
                db.update_video(int(video_id), {
                    'uploaded_to_youtube': True,
                    'youtube_upload_id': youtube_video_id
                })

            # Now that YouTube upload is complete, we can safely clean up if Drive upload also happened
            if video_id:
                video = db.get_video_by_id(int(video_id))
                if video and video.get('uploaded_to_drive') and os.path.exists(filename):
                    logger.info(f"Cleaning up file after successful uploads: {filename}")
                    try:
                        os.remove(filename)
                    except Exception as e:
                        logger.error(f"Error removing temporary file: {e}")

            return jsonify({
                'status': 'success',
                'message': 'Video uploaded successfully to YouTube',
                'youtube_video_id': youtube_video_id,
                'watch_url': f'https://www.youtube.com/watch?v={youtube_video_id}'
            })
        except Exception as e:
            error_message = str(e)
            logger.error(f"YouTube upload error: {error_message}")

            # Check for permission error
            if "insufficientPermissions" in error_message or "insufficient authentication scopes" in error_message:
                return jsonify({
                    'error': 'YouTube API permissions are missing. Please log out and log back in to grant all required permissions.',
                    'action_required': 'reauth',
                    'details': error_message
                }), 403

            return jsonify({'error': error_message}), 500

    @app.route('/download_file/<path:filename>')
    def download_file(filename):
        """Download a file to user's device"""
        try:
            # Ensure the file exists and is within the temp directory
            if not os.path.exists(filename) or not filename.startswith(temp_dir):
                return jsonify({'error': 'File not found'}), 404

            return send_file(
                filename,
                as_attachment=True,
                download_name=os.path.basename(filename)
            )
        except Exception as e:
            logger.error(f"Error downloading file: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/history', methods=['GET'])
    @login_required
    def get_history():
        """Get download/upload history for the current user"""
        try:
            # Get all videos from our JSON database for the current user
            if hasattr(current_user, 'id'):
                videos = db.get_user_videos(current_user.id)
            else:
                videos = []

            return jsonify({
                'status': 'success',
                'videos': videos
            })
        except Exception as e:
            logger.error(f"Error getting history: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/user_session', methods=['GET'])
    @login_required
    def user_session():
        """Get current user session data and associated download history"""
        try:
            # Get current user data
            user_data = current_user.to_dict()
            
            # Get user's download history (most recent 10 videos)
            recent_videos = db.get_user_videos(current_user.id)[:10]
            
            # Get summary statistics
            all_videos = db.get_user_videos(current_user.id)
            total_videos = len(all_videos)
            uploaded_videos = len([v for v in all_videos if v.get('uploaded_to_drive')])
            youtube_uploads = len([v for v in all_videos if v.get('uploaded_to_youtube')])
            
            return jsonify({
                'status': 'success',
                'user': user_data,
                'recent_history': recent_videos,
                'stats': {
                    'total_videos': total_videos,
                    'uploaded_to_drive': uploaded_videos,
                    'uploaded_to_youtube': youtube_uploads
                },
                'session_active': True
            })
        except Exception as e:
            logger.error(f"Error retrieving user session data: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/export_user_history', methods=['GET'])
    @login_required
    def export_user_history():
        """Export user's download history to a JSON file"""
        try:
            # Get all videos for the current user
            videos = db.get_user_videos(current_user.id)
            
            if not videos:
                return jsonify({'message': 'No videos found in your history'}), 404
                
            # Convert videos to a list of dictionaries
            history_data = {
                'user': current_user.to_dict(),
                'export_date': datetime.utcnow().isoformat(),
                'total_videos': len(videos),
                'videos': videos
            }
            
            # Create a unique filename
            timestamp = int(time.time())
            filename = os.path.join(temp_dir, f"user_{current_user.id}_history_{timestamp}.json")
            
            # Write JSON data to file
            with open(filename, 'w') as f:
                json.dump(history_data, f, indent=4)
            
            # Return the file as an attachment
            return send_file(
                filename,
                as_attachment=True,
                download_name=f"youtube_history_{timestamp}.json",
                mimetype='application/json'
            )
        except Exception as e:
            logger.error(f"Error exporting user history: {e}")
            return jsonify({'error': str(e)}), 500

def get_authenticated_service():
    """Build and return a Drive service object"""
    try:
        if 'credentials' not in session:
            logger.debug("No credentials in session")
            return None

        # Parse credentials from session
        creds_data = json.loads(session['credentials'])
        logger.debug(f"Credentials structure: {list(creds_data.keys())}")

        # Create credentials object
        credentials = Credentials(
            token=creds_data['token'],
            refresh_token=creds_data['refresh_token'],
            token_uri='https://oauth2.googleapis.com/token',
            client_id=os.environ.get('GOOGLE_OAUTH_CLIENT_ID', creds_data.get('client_id')),
            client_secret=os.environ.get('GOOGLE_OAUTH_CLIENT_SECRET', creds_data.get('client_secret')),
            scopes=creds_data['scopes']
        )

        # Force token refresh
        request = Request()
        credentials.refresh(request)

        # Update session with refreshed credentials
        updated_creds = {
            'token': credentials.token,
            'refresh_token': credentials.refresh_token,
            'token_uri': credentials.token_uri,
            'client_id': credentials.client_id,
            'client_secret': credentials.client_secret,
            'scopes': credentials.scopes
        }
        session['credentials'] = json.dumps(updated_creds)

        return build('drive', 'v3', credentials=credentials)
    except Exception as e:
        logger.error(f"Error getting authenticated service: {e}")
        return None

def register_routes(app):
    """Register all routes with the Flask app"""
    
    @app.route('/')
    def index():
        """Render the main page with options"""
        return render_template('index.html')

    @app.route('/download')
    def download_page():
        """Render the download page"""
        return render_template('download.html')

    @app.route('/metadata')
    def metadata_page():
        """Render the metadata extraction page"""
        return render_template('metadata.html')

    @app.route('/get_metadata', methods=['POST'])
    def get_metadata():
        """Extract metadata from YouTube URL"""
        try:
            data = request.get_json()
            url = data.get('url', '')

            if not is_valid_youtube_url(url):
                return jsonify({'error': 'Invalid YouTube URL'}), 400

            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

            return jsonify({
                'title': info.get('title', 'Unknown title'),
                'description': info.get('description', 'No description available'),
                'channel': info.get('uploader', 'Unknown channel'),
                'duration': format_duration(info.get('duration', 0)),
                'tags': info.get('tags', [])
            })
        except Exception as e:
            logger.error(f"Error extracting metadata: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/history_page')
    def history_page():
        """Render the history page"""
        return render_template('history.html')

    @app.route('/auth')
    def auth():
        """Start the OAuth flow - redirects to the Google Auth blueprint"""
        return redirect('/google_login')

    @app.route('/get_video_info', methods=['POST'])
    def get_video_info():
        """Get video information from YouTube URL"""
        try:
            data = request.get_json()
            url = data.get('url', '')

            # Validate YouTube URL
            parsed_url = urlparse(url)
            if 'youtube.com' not in parsed_url.netloc and 'youtu.be' not in parsed_url.netloc:
                return jsonify({'error': 'Invalid YouTube URL'}), 400

            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'skip_download': True,
                # Removed 'format': 'best' to let yt-dlp choose available formats
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

            return jsonify({
                'title': info.get('title', 'Unknown title'),
                'duration': info.get('duration', 0),
                'thumbnail': info.get('thumbnail', ''),
                'uploader': info.get('uploader', 'Unknown uploader'),
            })
        except Exception as e:
            logger.error(f"Error getting video info: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/download', methods=['POST'])
    def download_video():
        """Download video from YouTube URL"""
        data = request.get_json()
        logger.info(f"Download data received: {data}")

        url = data.get('url', '')

        # Create a unique filename
        timestamp = int(time.time())
        temp_file = os.path.join(temp_dir, f"yt_video_{timestamp}")
        temp_file_mp4 = temp_file + '.mp4'  # Default to mp4 for backup methods
        logger.info(f"Temp file path: {temp_file}")

        # For testing, use the simplest command possible
        try:
            subprocess.run(['pip', 'list'], capture_output=True, text=True)

            # Use most compatible format with resolution limit for faster download
            cmd = f"yt-dlp -f 'bestvideo[height<=360][ext=mp4]+bestaudio[ext=m4a]/mp4[height<=360]' --no-check-certificate --no-cache-dir -o '{temp_file_mp4}' '{url}'"
            logger.info(f"Running direct command: {cmd}")
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            try:
                stdout, stderr = process.communicate(timeout=240)  # 4 minute timeout
                if process.returncode != 0:
                    raise Exception(f"Download failed: {stderr.decode()}")
            except subprocess.TimeoutExpired:
                process.kill()
                raise Exception("Download timed out after 4 minutes")

            if os.path.exists(temp_file_mp4):
                logger.info(f"File downloaded successfully: {temp_file_mp4}")

                # Get metadata
                try:
                    with yt_dlp.YoutubeDL({'quiet': True, 'skip_download': True}) as ydl:
                        info = ydl.extract_info(url, download=False)

                    video_info = {
                        'youtube_id': info.get('id', ''),
                        'title': info.get('title', 'Unknown'),
                        'duration': info.get('duration', 0),
                        'thumbnail_url': info.get('thumbnail', ''),
                        'uploader': info.get('uploader', 'Unknown uploader'),
                        'filename': temp_file_mp4
                    }
                except Exception as e:
                    logger.warning(f"Could not get metadata: {e}")
                    # Fallback metadata
                    video_info = {
                        'youtube_id': url.split('v=')[-1] if 'v=' in url else url.split('/')[-1],
                        'title': os.path.basename(temp_file_mp4),
                        'duration': 0,
                        'thumbnail_url': '',
                        'uploader': 'Unknown',
                        'filename': temp_file_mp4
                    }

                return process_downloaded_video(url, video_info)

        except Exception as e:
            logger.error(f"Download error: {e}")

            # Last attempt - basic pytube
            try:
                logger.info("Trying basic pytube...")
                from pytube import YouTube
                yt = YouTube(url)
                highest_res_stream = yt.streams.get_highest_resolution()
                if highest_res_stream:
                    download_path = highest_res_stream.download(output_path=temp_dir, filename=f"yt_video_{timestamp}.mp4")
                    logger.info(f"Downloaded with pytube: {download_path}")

                    if os.path.exists(download_path):
                        video_info = {
                            'youtube_id': yt.video_id,
                            'title': yt.title,
                            'duration': yt.length,
                            'thumbnail_url': yt.thumbnail_url,
                            'uploader': yt.author,
                            'filename': download_path
                        }
                        return process_downloaded_video(url, video_info)
            except Exception as pytube_error:
                logger.error(f"Basic pytube error: {pytube_error}")

        # If all methods fail
        return jsonify({'error': 'All download methods failed'}), 500

    def process_downloaded_video(url, video_info):
        """Process a successfully downloaded video and create database entry"""
        try:
            filename = video_info['filename']
            # Get file size
            file_size = os.path.getsize(filename)
            logger.info(f"File size: {file_size} bytes")

            # Prepare video data for JSON database
            video_data = {
                'youtube_id': video_info['youtube_id'],
                'title': video_info['title'],
                'url': url,
                'duration': video_info['duration'],
                'thumbnail_url': video_info['thumbnail_url'],
                'uploader': video_info['uploader'],
                'file_size': file_size,
                'download_success': True,
                'uploaded_to_drive': False,
                'drive_file_id': None,
                'drive_folder_id': None,
                'uploaded_to_youtube': False,
                'youtube_upload_id': None,
                'user_id': current_user.id if hasattr(current_user, 'id') and not current_user.is_anonymous else None
            }

            # Create video record in JSON database
            video = db.create_video(video_data)
            logger.info(f"Video record created with ID: {video['id']}")

            # Add video ID to response for later reference
            response_data = {
                'status': 'success',
                'message': 'Video downloaded successfully',
                'filename': filename,
                'title': video_info['title'],
                'video_id': video['id']
            }
            logger.info(f"Sending response with data: {response_data}")
            return jsonify(response_data)
        except Exception as e:
            logger.error(f"Error processing downloaded video: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/upload_to_drive', methods=['POST'])
    def upload_to_drive():
        """Upload video to Google Drive"""
        try:
            data = request.get_json()
            filename = data.get('filename', '')
            folder_id = data.get('folder_id', None)
            video_id = data.get('video_id', None)

            if not os.path.exists(filename):
                return jsonify({'error': 'File not found'}), 404

            drive_service = get_authenticated_service()
            if not drive_service:
                return jsonify({'error': 'Not authenticated with Google Drive'}), 401

            # Create file metadata
            file_metadata = {
                'name': os.path.basename(filename),
            }

            if folder_id:
                file_metadata['parents'] = [folder_id]

            # Upload file
            media = MediaFileUpload(
                filename, 
                resumable=True
            )

            file = drive_service.files().create(
                body=file_metadata,
                media_body=media,
                fields='id'
            ).execute()

            # Update database record if video_id was provided
            if video_id:
                video = db.get_video_by_id(int(video_id))
                if video:
                    db.update_video(int(video_id), {
                        'uploaded_to_drive': True,
                        'drive_file_id': file.get('id'),
                        'drive_folder_id': folder_id
                    })

            return jsonify({
                'status': 'success',
                'message': 'Video uploaded to Google Drive',
                'file_id': file.get('id')
            })
        except Exception as e:
            logger.error(f"Upload error: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/get_drive_folders', methods=['GET'])
    def get_drive_folders():
        """Get list of Google Drive folders"""
        try:
            drive_service = get_authenticated_service()
            if not drive_service:
                return jsonify({'error': 'Not authenticated with Google Drive'}), 401

            # Query all folders including those in shared drives and shared with the user
            results = drive_service.files().list(
                q="mimeType='application/vnd.google-apps.folder'",
                spaces='drive',
                fields='files(id, name, parents)',
                pageSize=1000,  # Get maximum number of folders
                includeItemsFromAllDrives=True,
                supportsAllDrives=True
            ).execute()

            folders = results.get('files', [])
            logger.info(f"Found {len(folders)} folders")

            # Sort folders by name for better display
            folders.sort(key=lambda x: x.get('name', '').lower())

            return jsonify({'folders': folders})
        except Exception as e:
            logger.error(f"Error getting folders: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/api/upload_to_yt', methods=['POST'])
    def upload_to_yt():
        """Upload video to YouTube with original metadata"""
        try:
            data = request.get_json()
            logger.info(f"YouTube upload with original metadata data received: {data}")

            filename = data.get('filename', '')
            video_id = data.get('video_id', None)
            privacy_status = data.get('privacy_status', 'private')

            if not os.path.exists(filename):
                return jsonify({'error': 'File not found'}), 404

            # Get the original video's metadata
            if video_id:
                video = db.get_video_by_id(int(video_id))
                if not video:
                    return jsonify({'error': 'Video record not found'}), 404

                youtube_id = video['youtube_id']

                # Get metadata using yt-dlp
                try:
                    logger.info(f"Fetching metadata for video ID: {youtube_id}")

                    with yt_dlp.YoutubeDL({'quiet': True, 'skip_download': True}) as ydl:
                        info = ydl.extract_info(f"https://www.youtube.com/watch?v={youtube_id}", download=False)

                    title = info.get('title', 'Unknown title')
                    description = info.get('description', '')
                    tags = info.get('tags', [])
                    category_id = info.get('categories', ['22'])[0] if info.get('categories') else '22'

                    logger.info(f"Original metadata fetched: title='{title}', tags={tags}")
                except Exception as e:
                    logger.error(f"Error fetching original metadata: {e}")
                    return jsonify({'error': f'Could not fetch original metadata: {str(e)}'}), 500
            else:
                return jsonify({'error': 'Video ID is required for upload with original metadata'}), 400

            # Now upload to YouTube with the original metadata
            # Google OAuth credentials from session
            if 'credentials' not in session:
                return jsonify({'error': 'Not authenticated with Google, please login first'}), 401

            # Build the YouTube API service object
            creds_data = json.loads(session['credentials'])
            credentials = Credentials(
                token=creds_data['token'],
                refresh_token=creds_data['refresh_token'],
                token_uri=creds_data['token_uri'],
                client_id=creds_data['client_id'],
                client_secret=creds_data['client_secret'],
                scopes=creds_data['scopes']
            )

            # Check if YouTube scope is present
            if 'https://www.googleapis.com/auth/youtube.upload' not in credentials.scopes:
                return jsonify({'error': 'YouTube upload permission not granted', 'action_required': 'reauth'}), 403

            # Build YouTube API client
            youtube = build('youtube', 'v3', credentials=credentials)

            # Prepare video upload metadata
            body = {
                'snippet': {
                    'title': title,
                    'description': description,
                    'tags': tags,
                    'categoryId': '22'  # Using default category 22 (People & Blogs) as safe default
                },
                'status': {
                    'privacyStatus': privacy_status,
                    'embeddable': True
                }
            }

            # Upload the video
            media = MediaFileUpload(
                filename,
                resumable=True
            )

            # Execute the upload request
            insert_request = youtube.videos().insert(
                part=','.join(body.keys()),
                body=body,
                media_body=media
            )

            # This is a simplified version without a resumable upload
            response = insert_request.execute()

            logger.info(f"YouTube upload successful: {response}")

            # Update database
            if video_id:
                db.update_video(int(video_id), {
                    'uploaded_to_youtube': True,
                    'youtube_upload_id': response.get('id')
                })

            return jsonify({
                'status': 'success',
                'message': 'Video uploaded to YouTube with original metadata',
                'youtube_video_id': response.get('id')
            })

        except Exception as e:
            logger.error(f"Error uploading to YouTube with original metadata: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/upload_to_youtube', methods=['POST'])
    def upload_to_youtube():
        """Upload video to YouTube"""
        try:
            data = request.get_json()
            logger.info(f"YouTube upload data received: {data}")

            filename = data.get('filename', '')
            video_id = data.get('video_id', None)
            title = data.get('title', os.path.basename(filename))
            description = data.get('description', 'Uploaded via YouTube Downloader App')
            tags = data.get('tags', '').split(',') if data.get('tags') else []
            category_id = data.get('category_id', '22')  # Default: "People & Blogs"
            privacy_status = data.get('privacy_status', 'private')  # Default: private

            logger.info(f"Checking file: {filename}, exists: {os.path.exists(filename) if filename else 'No filename provided'}")

            if not filename:
                return jsonify({'error': 'No video file available for upload'}), 400

            if not os.path.exists(filename):
                return jsonify({'error': 'File not found'}), 404

            # Get authenticated service
            credentials_data = json.loads(session.get('credentials', '{}'))
            if not credentials_data:
                return jsonify({'error': 'Not authenticated with Google'}), 401

            credentials = Credentials(
                token=credentials_data.get('token'),
                refresh_token=credentials_data.get('refresh_token'),
                token_uri=credentials_data.get('token_uri'),
                client_id=credentials_data.get('client_id'),
                client_secret=credentials_data.get('client_secret'),
                scopes=credentials_data.get('scopes')
            )

            if credentials.expired:
                request_obj = Request()
                credentials.refresh(request_obj)
                # Update stored credentials
                credentials_data['token'] = credentials.token
                session['credentials'] = json.dumps(credentials_data)

            youtube_service = build('youtube', 'v3', credentials=credentials)

            # Create video metadata
            body = {
                'snippet': {
                    'title': title,
                    'description': description,
                    'tags': tags,
                    'categoryId': '22'  # Using default category 22 (People & Blogs) as safe default
                },
                'status': {
                    'privacyStatus': privacy_status
                }
            }

            # Create media upload with progress reporting
            media = MediaFileUpload(
                filename, 
                mimetype='video/mp4',
                resumable=True,
                chunksize=1024*1024
            )

            # Upload video
            request_obj = youtube_service.videos().insert(
                part=','.join(body.keys()),
                body=body,
                media_body=media
            )

            response = None
            last_progress = 0

            while response is None:
                status, response = request_obj.next_chunk()
                if status:
                    progress = int(status.progress() * 100)
                    # Only log if progress has changed significantly
                    if progress - last_progress >= 5:
                        logger.info(f"YouTube upload progress: {progress}%")
                        last_progress = progress

            youtube_video_id = response.get('id')
            logger.info(f"Video uploaded successfully to YouTube. ID: {youtube_video_id}")

            # Update database record
            if video_id:
                db.update_video(int(video_id), {
                    'uploaded_to_youtube': True,
                    'youtube_upload_id': youtube_video_id
                })

            # Now that YouTube upload is complete, we can safely clean up if Drive upload also happened
            if video_id:
                video = db.get_video_by_id(int(video_id))
                if video and video.get('uploaded_to_drive') and os.path.exists(filename):
                    logger.info(f"Cleaning up file after successful uploads: {filename}")
                    try:
                        os.remove(filename)
                    except Exception as e:
                        logger.error(f"Error removing temporary file: {e}")

            return jsonify({
                'status': 'success',
                'message': 'Video uploaded successfully to YouTube',
                'youtube_video_id': youtube_video_id,
                'watch_url': f'https://www.youtube.com/watch?v={youtube_video_id}'
            })
        except Exception as e:
            error_message = str(e)
            logger.error(f"YouTube upload error: {error_message}")

            # Check for permission error
            if "insufficientPermissions" in error_message or "insufficient authentication scopes" in error_message:
                return jsonify({
                    'error': 'YouTube API permissions are missing. Please log out and log back in to grant all required permissions.',
                    'action_required': 'reauth',
                    'details': error_message
                }), 403

            return jsonify({'error': error_message}), 500

    @app.route('/download_file/<path:filename>')
    def download_file(filename):
        """Download a file to user's device"""
        try:
            # Ensure the file exists and is within the temp directory
            if not os.path.exists(filename) or not filename.startswith(temp_dir):
                return jsonify({'error': 'File not found'}), 404

            return send_file(
                filename,
                as_attachment=True,
                download_name=os.path.basename(filename)
            )
        except Exception as e:
            logger.error(f"Error downloading file: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/history', methods=['GET'])
    @login_required
    def get_history():
        """Get download/upload history for the current user"""
        try:
            # Get all videos from our JSON database for the current user
            if hasattr(current_user, 'id'):
                videos = db.get_user_videos(current_user.id)
            else:
                videos = []

            return jsonify({
                'status': 'success',
                'videos': videos
            })
        except Exception as e:
            logger.error(f"Error getting history: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/user_session', methods=['GET'])
    @login_required
    def user_session():
        """Get current user session data and associated download history"""
        try:
            # Get current user data
            user_data = current_user.to_dict()
            
            # Get user's download history (most recent 10 videos)
            recent_videos = db.get_user_videos(current_user.id)[:10]
            
            # Get summary statistics
            all_videos = db.get_user_videos(current_user.id)
            total_videos = len(all_videos)
            uploaded_videos = len([v for v in all_videos if v.get('uploaded_to_drive')])
            youtube_uploads = len([v for v in all_videos if v.get('uploaded_to_youtube')])
            
            return jsonify({
                'status': 'success',
                'user': user_data,
                'recent_history': recent_videos,
                'stats': {
                    'total_videos': total_videos,
                    'uploaded_to_drive': uploaded_videos,
                    'uploaded_to_youtube': youtube_uploads
                },
                'session_active': True
            })
        except Exception as e:
            logger.error(f"Error retrieving user session data: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/export_user_history', methods=['GET'])
    @login_required
    def export_user_history():
        """Export user's download history to a JSON file"""
        try:
            # Get all videos for the current user
            videos = db.get_user_videos(current_user.id)
            
            if not videos:
                return jsonify({'message': 'No videos found in your history'}), 404
                
            # Convert videos to a list of dictionaries
            history_data = {
                'user': current_user.to_dict(),
                'export_date': datetime.utcnow().isoformat(),
                'total_videos': len(videos),
                'videos': videos
            }
            
            # Create a unique filename
            timestamp = int(time.time())
            filename = os.path.join(temp_dir, f"user_{current_user.id}_history_{timestamp}.json")
            
            # Write JSON data to file
            with open(filename, 'w') as f:
                json.dump(history_data, f, indent=4)
            
            # Return the file as an attachment
            return send_file(
                filename,
                as_attachment=True,
                download_name=f"youtube_history_{timestamp}.json",
                mimetype='application/json'
            )
        except Exception as e:
            logger.error(f"Error exporting user history: {e}")
            return jsonify({'error': str(e)}), 500